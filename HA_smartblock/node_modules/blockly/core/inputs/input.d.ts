// src/import/blocks/trigger_mapper.js
import * as Blockly from 'blockly';

/**
 * Blockly에서 특정 타입의 블록을 생성할 수 있는지 확인합니다.
 * (yamlToBlocks.js에서 복사하거나 import해야 하는 헬퍼 함수)
 */
function canCreate(type) {
  try {
    return !!Blockly.Blocks[type];
  } catch { return false; }
}

/**
 * YAML 트리거 데이터를 Blockly 이벤트 블록으로 변환합니다.
 * @param {object} t - 정규화된 단일 트리거 객체
 * @param {Blockly.WorkspaceSvg} workspace - 작업 공간
 * @returns {Blockly.Block|null} 생성된 트리거 블록
 */
export function createTriggerBlock(t, workspace) {
  
  // 현재 정의된 블록은 'state' 트리거와 'Home Assistant' 이벤트만 처리 가능
  if (t.platform && t.platform !== 'state') return null;

  // platform: Home Assistant 이벤트 처리 (start/shutdown)
  if (!t.platform && t.event) { 
      if (canCreate('ha_event_homeassistant')) {
          const b = workspace.newBlock('ha_event_homeassistant');
          if (b.getField('EVENT') && t.event) {
              b.setFieldValue(String(t.event), 'EVENT');
          }
          return b;
      }
      return null;
  }
  
  // platform: state 트리거 처리
  const domain = t.entity_id ? t.entity_id.split('.')[0] : null;
  let TYPE = null;

  // 1. 도메인 및 속성 기반 매핑
  if (domain === 'light' && canCreate('ha_event_light_state')) TYPE = 'ha_event_light_state';
  else if (domain === 'binary_sensor' && canCreate('ha_event_binary_state')) TYPE = 'ha_event_binary_state';
  else if (domain === 'switch' && canCreate('ha_event_switch_state')) TYPE = 'ha_event_switch_state';
  else if (domain === 'lock' && canCreate('ha_event_lock_state')) TYPE = 'ha_event_lock_state';
  // numeric_state는 'above'나 'below'가 있을 경우를 가정
  else if (domain === 'sensor' && (t.above != null || t.below != null) && canCreate('ha_event_numeric_state_sensor')) {
      TYPE = 'ha_event_numeric_state_sensor';
  }
  
  // 2. 폴백(Fallback): 도메인별 매핑 실패 시, 가장 일반적인 light_state를 기본으로 사용
  if (!TYPE && canCreate('ha_event_light_state')) {
      TYPE = 'ha_event_light_state'; 
  } else if (!TYPE) {
      return null;
  }
  
  const b = workspace.newBlock(TYPE);

  // 3. 엔티티 ID 필드 설정 (모든 블록에서 'ENTITY' 필드를 사용함)
  if (b.getField('ENTITY') && (t.entity_id || t.entity)) {
    b.setFieldValue(t.entity_id || t.entity || '', 'ENTITY');
  }

  // 4. FROM, TO 필드 설정 (모든 상태 블록에서 사용함)
  if (b.getField('FROM') && t.from != null) b.setFieldValue(String(t.from), 'FROM');
  if (b.getField('TO') && t.to != null) b.setFieldValue(String(t.to), 'TO');
  
  // 5. Numeric State 필드 설정 (ha_event_numeric_state_sensor 전용)
  if (TYPE === 'ha_event_numeric_state_sensor') {
      if (b.getField('ABOVE') && t.above != null) b.setFieldValue(String(t.above), 'ABOVE');
      if (b.getField('BELOW') && t.below != null) b.setFieldValue(String(t.below), 'BELOW');
  }

  // 6. for 처리: ha_event_for_hms 블록을 생성하여 Value Input 'FOR'에 부착
  if (t.for && canCreate('ha_event_for_hms')) {
      const forBlock = workspace.newBlock('ha_event_for_hms');
      forBlock.setFieldValue(String(t.for.hours ?? 0), 'H');
      forBlock.setFieldValue(String(t.for.minutes ?? 0), 'M');
      forBlock.setFieldValue(String(t.for.seconds ?? 0), 'S');
      forBlock.initSvg();
      forBlock.render();
      
      // Value Input 이름 'FOR' 사용
      const durationInput = b.getInput('FOR'); 
      if (durationInput && durationInput.connection) {
          durationInput.connection.connect(forBlock.outputConnection);
      }
  }

  return b;
}